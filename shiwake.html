<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çµµæ–‡å­—ä»•åˆ†ã‘</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #F8FAFC; font-family: sans-serif; }
        canvas { display: block; }
    </style>
</head>
<body>
<script>
// --- ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿è¨­å®š ---
let stages = [
  { pair: ["ğŸ‘", "â˜ï¸"], goal: 5, bgL: "#FFDEE9", bgR: "#B5FFFC", speed: 2.5, span: 75 },
  { pair: ["â­", "ğŸŒ™"], goal: 7, bgL: "#D1D5DB", bgR: "#93C5FD", speed: 3.0, span: 65 },
  { pair: ["ğŸ§Š", "ğŸ•¯ï¸"], goal: 8, bgL: "#FED7AA", bgR: "#FEE2E2", speed: 3.5, span: 55 },
  { pair: ["ğŸ«§", "ğŸ¬"], goal: 10, bgL: "#BFDBFE", bgR: "#DBEAFE", speed: 4.0, span: 45 },
  { pair: ["ğŸ€", "ğŸ§¸"], goal: 12, bgL: "#DDD6FE", bgR: "#F5D0FE", speed: 4.5, span: 40 },
  { pair: ["â˜„ï¸", "ğŸª"], goal: 15, bgL: "#312E81", bgR: "#4C1D95", speed: 5.0, span: 35 },
  { pair: ["ğŸƒ", "ğŸ"], goal: 13, bgL: "#DCFCE7", bgR: "#BBF7D0", speed: 5.5, span: 32 },
  { pair: ["âœ¨", "ğŸ’"], goal: 11, bgL: "#E0F2F1", bgR: "#B2DFDB", speed: 6.0, span: 30 },
  { pair: ["ğŸƒ", "ğŸ‘»"], goal: 14, bgL: "#1F2937", bgR: "#4B5563", speed: 6.5, span: 28 },
  { pair: ["ğŸŒ¦ï¸", "ğŸŒˆ"], goal: 20, bgL: "#FDF2F8", bgR: "#E0F2F1", speed: 7.0, span: 25 }
];

let badEmoji = "ğŸ¥º";
let gameTitle = "çµµæ–‡å­—ä»•åˆ†ã‘"; 
let currentStage = 0;
let isChaosMode = false; 
let targetEmoji, otherEmoji, targetSide;
let targetCount, gameState = "START";
let leftStack = [], rightStack = [], particles = [];
let activeEmojis = [];
let spawnTimer = 0;
let startTime, totalScore = 0;
let highScores = [];
let chaosSpeed = 2.5; 
let chaosSpan = 75;
let lives = 3;
let maxLives = 3;

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);
  let saved = localStorage.getItem('emojiSortingRanking');
  if (saved) highScores = JSON.parse(saved);
  initStage();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  if (gameState === "START") drawStartScreen();
  else if (gameState === "PLAY") drawGamePlay();
  else if (gameState === "STAGE_CLEAR") drawFeverScreen();
}

// --- ãƒˆãƒƒãƒ—ç”»é¢ï¼ˆãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¬ã‚¤ãƒ‰ä»˜ãï¼‰ ---
function drawStartScreen() {
  background("#F8FAFC");
  
  // ã‚¿ã‚¤ãƒˆãƒ«
  fill(71, 85, 105);
  textSize(min(width * 0.1, 50));
  textStyle(BOLD);
  text(gameTitle, width / 2, height * 0.12);
  
  // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¬ã‚¤ãƒ‰ã®æç”»
  drawVisualManual();
  
  // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
  let btnY = height * 0.72;
  fill("#64748B");
  noStroke();
  rectMode(CENTER);
  rect(width / 2, btnY, 220, 70, 20);
  fill(255);
  textSize(24);
  textStyle(NORMAL);
  text("GAME START", width / 2, btnY + 2);
  
  // ãƒ©ãƒ³ã‚­ãƒ³ã‚°
  rectMode(CORNER);
  fill(148, 163, 184);
  textSize(14);
  text("ğŸ† TOP RECORDS", width / 2, height * 0.82);
  for (let i = 0; i < 5; i++) {
    let entry = highScores[i] ? `${highScores[i].score} pts (Lv.${highScores[i].lv})` : "---";
    text(entry, width / 2, height * 0.85 + (i * 20));
  }
}

// å›³è§£ãƒ‘ãƒ¼ãƒ„ã‚’æç”»ã™ã‚‹é–¢æ•°
function drawVisualManual() {
  let panelW = width * 0.28;
  let panelH = height * 0.3;
  let startY = height * 0.25;
  let spacing = width * 0.32;
  
  // 1. ä»•åˆ†ã‘
  drawPanel(width/2 - spacing, startY, panelW, panelH, "1.ä»•åˆ†ã‘", "å·¦å³ã‚’ã‚¿ãƒƒãƒ—", "ğŸ‘ˆ ğŸ ğŸ ğŸ‘‰");
  
  // 2. ç¢ºå®š
  drawPanel(width/2, startY, panelW, panelH, "2.ç¢ºå®š", "æ•°ãˆã¦ãƒœã‚¿ãƒ³", "5 / 5 [ç¢ºå®š]");
  
  // 3. ãŠé‚ªé­”
  drawPanel(width/2 + spacing, startY, panelW, panelH, "3.ãŠé‚ªé­”", "ğŸ¥ºã‚’ã‚¿ãƒƒãƒ—", "ğŸ’¥ ğŸ¥º ğŸ’¥");
}

function drawPanel(x, y, w, h, title, sub, visual) {
  push();
  translate(x, y + h/2);
  fill(255);
  stroke(226, 232, 240);
  strokeWeight(2);
  rectMode(CENTER);
  rect(0, 0, w, h, 15);
  
  noStroke();
  fill(100);
  textSize(14);
  textStyle(BOLD);
  text(title, 0, -h/2 + 25);
  
  fill(130);
  textSize(11);
  textStyle(NORMAL);
  text(sub, 0, -h/2 + 45);
  
  fill(71, 85, 105);
  textSize(w * 0.2);
  text(visual, 0, 15);
  pop();
}

// --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå‰å›ã®æ©Ÿèƒ½ã‚’ã™ã¹ã¦ç¶­æŒï¼‰ ---
function drawGamePlay() {
  let s = isChaosMode ? {bgL:"#000", bgR:"#111", speed:chaosSpeed, span:chaosSpan} : stages[currentStage];
  noStroke();
  fill(s.bgL); rect(0, 0, width/2, height);
  fill(s.bgR); rect(width/2, 0, width/2, height);
  
  fill(255, 200); rect(width*0.05, 30, width*0.9, 140, 20);
  
  textSize(24);
  let heartText = "";
  for(let i=0; i<maxLives; i++) heartText += (i < lives) ? "â¤ï¸" : "ğŸ–¤";
  text(heartText, width/2, height - 140);

  fill(71, 85, 105);
  let lvLabel = isChaosMode ? "CHAOS MODE (åŠ é€Ÿä¸­ï¼)" : "Level " + (currentStage + 1);
  textSize(16); text(lvLabel, width/2, 55);
  
  textSize(18);
  let leftT = (targetSide === "LEFT") ? "æ•°ãˆã‚‹: " + targetEmoji : otherEmoji;
  let rightT = (targetSide === "RIGHT") ? "æ•°ãˆã‚‹: " + targetEmoji : otherEmoji;
  text("â† " + leftT, width*0.25, 85);
  text(rightT + " â†’", width*0.75, 85);
  
  textSize(22); textStyle(BOLD);
  if (isChaosMode) {
    fill("#ff4d4d");
    text(targetEmoji + " ã‚’ãƒŸã‚¹ã™ã‚‹ã¾ã§ä»•åˆ†ã‘ã¾ã—ã‚‡ã†ï¼", width/2, 125);
  } else {
    fill(71, 85, 105);
    text(targetEmoji + " ã‚’ [ " + stages[currentStage].goal + " ] å€‹æ•°ãˆã¾ã—ã‚‡ã†ï¼", width/2, 125);
  }
  textStyle(NORMAL);

  handleActiveEmojis();
  drawStacks();

  rectMode(CENTER);
  fill(71, 85, 105); rect(width/2, height - 70, 140, 55, 15);
  fill(255); textSize(20); text("ç¢ºå®š", width/2, height - 68);
  rectMode(CORNER);
}

function handleActiveEmojis() {
  let s = isChaosMode ? {speed:chaosSpeed, span:chaosSpan, pair:["ğŸ”¥","ğŸ’€"]} : stages[currentStage];
  spawnTimer++;
  if (spawnTimer >= s.span) {
    let r = random();
    let emoji = (r < 0.25) ? badEmoji : (random() > 0.5 ? s.pair[0] : s.pair[1]);
    activeEmojis.push({ emoji: emoji, x: random(width*0.1, width*0.9), y: -100, size: width * 0.2 });
    spawnTimer = 0;
  }
  for (let i = activeEmojis.length - 1; i >= 0; i--) {
    let e = activeEmojis[i];
    textSize(e.size); text(e.emoji, e.x, e.y);
    e.y += s.speed;
    if (e.y > height + 100) {
      if (e.emoji === badEmoji) reduceLife("ğŸ¥ºã‚’è¦‹é€ƒã—ã¾ã—ãŸï¼");
      activeEmojis.splice(i, 1);
    }
  }
}

function drawStacks() {
  textSize(width * 0.15); 
  for (let item of leftStack) {
    push(); translate(item.x, item.y); rotate(item.angle); text(item.emoji, 0, 0); pop();
  }
  for (let item of rightStack) {
    push(); translate(item.x, item.y); rotate(item.angle); text(item.emoji, 0, 0); pop();
  }
}

function touchStarted() {
  handleInput(mouseX, mouseY);
  return false; 
}

function mousePressed() {
  handleInput(mouseX, mouseY);
}

function handleInput(x, y) {
  if (gameState === "START") {
    let btnY = height * 0.72;
    if (x > width/2 - 110 && x < width/2 + 110 && y > btnY - 35 && y < btnY + 35) {
      gameState = "PLAY"; startTime = millis();
    }
    return;
  }
  if (gameState === "PLAY") {
    if (x > width/2 - 70 && x < width/2 + 70 && y > height - 100 && y < height - 40) {
      checkResult(); return;
    }
    if (activeEmojis.length > 0) {
      let first = activeEmojis[0];
      let d = dist(x, y, first.x, first.y);
      if (first.emoji === badEmoji) {
        if (d < 80) { activeEmojis.splice(0, 1); return; }
        else { reduceLife("ğŸ¥ºã¯æœ¬ä½“ã‚’ç›´æ¥ã‚¿ãƒƒãƒ—ã—ã¾ã—ã‚‡ã†ï¼"); return; }
      }
      if (x > width / 2) success("RIGHT", first.emoji);
      else success("LEFT", first.emoji);
      activeEmojis.splice(0, 1);
      if (isChaosMode) {
        shuffleRule(true);
        chaosSpeed += 0.15;
        chaosSpan = max(15, chaosSpan - 1); 
      }
    }
  } else if (gameState === "STAGE_CLEAR") nextStage();
}

function shuffleRule(chaos = false) {
  let s = chaos ? {pair:["ğŸ”¥","ğŸ’€"]} : stages[currentStage];
  if (random() > 0.5) { targetEmoji = s.pair[0]; otherEmoji = s.pair[1]; }
  else { targetEmoji = s.pair[1]; otherEmoji = s.pair[0]; }
  targetSide = random() > 0.5 ? "RIGHT" : "LEFT";
}

function success(side, emoji) {
  let isTarget = (emoji === targetEmoji);
  let isCorrectSide = (side === targetSide);
  let isCorrect = (isTarget && isCorrectSide) || (!isTarget && !isCorrectSide);
  if (!isCorrect) { reduceLife("ä»•åˆ†ã‘ãƒŸã‚¹ã§ã™ğŸ˜"); return; }
  if (isTarget) targetCount++;
  let item = {
    emoji: emoji, 
    x: (side === "RIGHT") ? width - random(30, 80) : random(30, 80),
    y: height - 180 - ((side === "RIGHT" ? rightStack.length : leftStack.length) * 8) + random(-15, 15),
    angle: random(-0.8, 0.8)
  };
  if (side === "RIGHT") rightStack.push(item); else leftStack.push(item);
}

function reduceLife(msg) {
  lives--;
  if (lives <= 0) {
    alert(msg + "\nãƒ©ã‚¤ãƒ•ãŒãªããªã‚Šã¾ã—ãŸ...");
    fail("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼");
  } else {
    alert(msg + "\nãƒ©ã‚¤ãƒ•ã‚’1ã¤å¤±ã„ã¾ã—ãŸã€‚ã“ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ã‚„ã‚Šç›´ã—ã¾ã™ï¼\nã®ã“ã‚Šãƒ©ã‚¤ãƒ•: " + lives);
    initStage();
    startTime = millis();
  }
}

function fail(msg) {
  alert(msg);
  saveScore();
  resetGame();
}

function resetGame() {
  currentStage = 0; totalScore = 0; isChaosMode = false;
  chaosSpeed = 2.5; chaosSpan = 75; 
  lives = 3; 
  gameState = "START";
  initStage();
}

function checkResult() {
  if (isChaosMode) {
     alert("ã‚«ã‚ªã‚¹ãƒ¢ãƒ¼ãƒ‰ã«çµ‚ã‚ã‚Šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\nãƒŸã‚¹ã™ã‚‹ã¾ã§é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼");
     return;
  }
  if (targetCount === stages[currentStage].goal) {
    let timeTaken = (millis() - startTime) / 1000;
    let stageScore = floor((2000 / timeTaken) * (currentStage + 1));
    totalScore += stageScore;
    gameState = "STAGE_CLEAR";
    for(let i=0; i<60; i++) particles.push({x: random(width), y: random(-height, 0), s: random(5, 12)});
  } else {
    reduceLife(`æ•°ãŒé•ã„ã¾ã™ï¼ æ­£è§£ã¯ ${targetCount} å€‹ã§ã—ãŸã€‚`);
  }
}

function saveScore() {
  if (totalScore > 0 || isChaosMode) {
    let label = isChaosMode ? "CHAOS" : currentStage + 1;
    highScores.push({ score: totalScore, lv: label });
    highScores.sort((a, b) => b.score - a.score);
    highScores = highScores.slice(0, 5);
    localStorage.setItem('emojiSortingRanking', JSON.stringify(highScores));
  }
}

function drawFeverScreen() {
  background("#FEF3C7");
  textSize(width * 0.2);
  for (let p of particles) {
    text(targetEmoji, p.x, p.y);
    p.y += p.s;
    if (p.y > height) p.y = -80;
  }
  fill(255, 240); rect(width/2 - 140, height/2 - 70, 280, 140, 20);
  fill(71, 85, 105); textSize(24); 
  text(`ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ğŸ¥³\nScore: ${totalScore}\næ¬¡ã¸é€²ã¿ã¾ã—ã‚‡ã†ğŸƒâ€â™€ï¸`, width/2, height/2);
}

function nextStage() {
  particles = [];
  currentStage++;
  if (currentStage >= stages.length) { 
    if (!isChaosMode) {
      alert("å…¨ã‚¹ãƒ†ãƒ¼ã‚¸å®Œå…¨æ”»ç•¥ã§ã™ğŸ‰\nãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ğŸŠã‚«ã‚ªã‚¹ã‚¹ãƒ†ãƒ¼ã‚¸ã«çªå…¥ã§ã™");
      isChaosMode = true;
      chaosSpeed = 2.5; chaosSpan = 75;
    }
  }
  gameState = "PLAY"; startTime = millis();
  initStage();
}